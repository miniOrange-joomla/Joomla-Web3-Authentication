jQuery(document).ready(function($){
    var root_url = document.getElementById('mo_root_url').value;
    ajaxurl = root_url+'ajax.php';
});

var isTesting, publicAddress, is_testing_wallet_address = !1, connectButton = document.getElementById("perawallet-connect");
let userLoginData = {
    state: "loggedOut",
    ethAddress: "",
    buttonText: "Log in",
    publicName: "",
    config: {headers: {"Content-Type": "application/x-www-form-urlencoded"}}
};

async function connectToMyAlgo(e = 0) {
    // Get the nonce value from an HTML element (used for verification)
    let mo_nonce = document.getElementById('mo_points').value;
    
    // Initialize the MyAlgoConnect object for Algorand wallet connection
    let t = new MyAlgoConnect;

    try {
        // Request user to connect their Algorand wallet and fetch available addresses
        let n = await t.connect({ shouldSelectOneAccount: !1, openManager: !1 });

        // Extract addresses from the response
        let s = n.map(e => e.address);
        let o = s[0], r = o; 

        // Send a login request to the server with the user's wallet address and nonce
        jQuery.post(ajaxurl, {
            action: "type_of_request",
            request: "login",
            address: r,
            mo_web3_verify_nonce: mo_nonce
        }, async function (n) {
            // If the response does not start with "Error", proceed with signing
            if ("Error" !== n.substring(0, 5)) {
                try {
                    var s, o;

                    // Request the user to sign the received message for authentication
                    let a = await t.signBytes(n, r);
                    s = a, o = r;

                    // Set traditional Ajax settings
                    jQuery.ajaxSettings.traditional = !0;

                    // Send the signed message back to the server for verification
                    jQuery.post(ajaxurl, {
                        action: "type_of_request",
                        address: o,
                        request: "auth_algorand",
                        signature: s,
                        mo_web3_verify_nonce: mo_nonce
                    }, async function (t) {
                        // If the signature is verified, proceed with further actions
                        if (t.isSignatureVerified) {
                            if (e) {
                                openModal(o); // Open a modal with user details
                            }
                        } else {
                            alert("User could not be authenticated!");
                        }
                    });

                } catch (i) {
                    alert(i); // Alert the user if an error occurs during signing
                    return;
                }
            }
        });

    } catch (a) {
        return; // If there's an error in the connection, simply exit
    }
}


const getPhantomProvider = () => {
    let e = window, t = e.phantom?.solana;
    if (t?.isPhantom) return t
};

async function getAccount(e = 0) {

    let mo_nonce = document.getElementById('mo_points').value;
    let t = window.solana && window.solana.isPhantom, n;
    if (!0 == t) {
        let s = getPhantomProvider(), o = await s.connect();
        var r = {
            action: "type_of_request",
            request: "login",
            address: n = o.publicKey.toString(),
            mo_web3_verify_nonce: mo_nonce
        };
        jQuery.post(ajaxurl, r, function (t) {
            if ("Error" !== t.substring(0, 5)) {
                let n = new TextEncoder().encode(t);
                alert(n);
                try {
                    var s, o;
                    solana.request({ method: "signMessage", params: { message: n } })
                        .then(function (r) {
                            let s = r.signature;
                            let o = r.publicKey;
                            jQuery.post(ajaxurl, {
                                action: "type_of_request",
                                address: o,
                                request: "auth_phantom",
                                signature: s,
                                mo_web3_verify_nonce: mo_nonce
                            }, function (t) {
                                t = jQuery.parseJSON(t);
                                if (t.isSignatureVerified) {
                                    if (e) {
                                        openModal(o);
                                    } else {
                                        let n = o;
                                        if (is_testing_wallet_address) {
                                            n = is_testing_wallet_address;
                                        }
                                    }
                                } else {
                                    alert("User could not be authenticated");
                                }
                            });
                        });

                } catch (a) {
                    alert(a);
                    return
                }
            }
        })
    } else window.alert("Use phantom mobile app's inbuilt browser")
}

function disconnectAccount() {
    window.solana.disconnect(), window.solana.on("disconnect", () => console.log("disconnected!"))
}

function checkMetamask() {
    if (window.ethereum) {
        let e = document.getElementById("buttonText");
        return e.style.cursor = "not-allowed", e.disabled = !0, showMessage("<strong>Error:</strong> To login, first install a Web3 wallet like the Metamask browser extension or mobile app"), 1
    }
    return 0
}

const ethEnabled = async () => {
    if (window.ethereum) {
        try {
            await window.ethereum.request({method: "eth_requestAccounts"}), window.web3 = new Web3(window.ethereum), ethInit()
        } catch (e) {
            return showMessage(e.message, "msg"), console.log("Error: ", e), !1
        }
        return !0
    }
};

function ethInit() {
    ethereum.on("accountsChanged", t => e());

    async function e() {
        try {
            let e = (await window.ethereum.request({method: "eth_requestAccounts"}))[0];
            e = e.toLowerCase()
        } catch (t) {
            console.log(t)
        }
    }
}

async function userLoginOut(param = 0, provider = null, shortcode = !1, redirectionUrl = null) {
   
    "metamask" == provider ? await connectWithMetaMask() : "walletConnect" == provider ? await connectWithWalletConnect() : "coinbase" == provider && await connectWithCoinBase();
    let msg = "";
  
    if (isTesting = param, (msg = await onConnectLoadWeb3Modal()).err) {
        showMessage(msg.err);
        return
    }
    if (web3ModalProv) {
        window.web3 = web3ModalProv;
        try {
            userLogin(redirectionUrl)
        } catch (r) {
            return
        }
    }
}

// This function is used to authenticate a user by requesting their wallet address, having them sign a unique message, and verifying the signature with the server.
async function userLogin(e) {
    // Get the nonce value (used for verification) from the HTML element with id 'mo_points'
    let mo_nonce = document.getElementById('mo_points').value;
    let t;

    try {
        // Request the user's Ethereum account addresses using web3
        t = await web3.eth.getAccounts();
    } catch (n) {
        // Log an error if there's a problem fetching accounts
        console.error("error ", n.message);
    }

    // Get the first Ethereum account from the list
    let s = t[0];

    // Check if the address is null and ensure it's in lowercase format
    if (null == (s = s.toLowerCase())) {
        // If no wallet address is found, display an error message
        showMessage("<strong>Error:</strong> No wallet address found");
        return;
    }

    // Prepare the data for sending a login request to the server
    var o = { action: "type_of_request", request: "login", address: s, mo_web3_verify_nonce: mo_nonce };

    // Send the login request to the server using jQuery's POST method
    jQuery.post(ajaxurl, o, async function (t) {
        console.log("Server response:", t);  // Log the server's response

        var n, o;
        
        // Check if the server response is a string (message to be signed)
        if (typeof t === 'string') {
            n = t; // Assign the response (message) to variable 'n'
            o = publicAddress = s; // Assign the user's wallet address to 'o' and 'publicAddress'

            console.log("Message to sign:", n);
            console.log("Public address:", o);

            try {
                // Show a message asking the user to sign the message
                showMessage("Waiting for your signature", "msg");

                // Ensure that web3 is initialized and defined
                if (typeof web3 === 'undefined') {
                    console.error("web3 is not defined");
                    showMessage("<strong>Error:</strong> web3 is not defined");
                    return;
                }

                // Prepare the message to sign and request the user to sign it using their wallet
                messageToSign = n;
                const signature = await web3.eth.personal.sign(web3.utils.utf8ToHex(messageToSign), o);
                console.log("Signature obtained:", signature);  // Log the signature obtained

                // Send the signed message back to the server for verification
                const response = await jQuery.post(ajaxurl, {
                    action: "type_of_request",
                    address: publicAddress,
                    request: "auth",
                    signature: signature,
                    mo_web3_verify_nonce: mo_nonce
                });

                // Parse the server's response to check if the signature is verified
                const parsedResponse = jQuery.parseJSON(response);
                if (parsedResponse.isSignatureVerified) {
                    // If verified, open the modal (if testing mode is enabled)
                    if (isTesting) {
                        openModal(publicAddress);
                    }
                } else {
                    // If not verified, show an alert
                    alert('Not verified');
                }
            } catch (e) {
                // Log any error that occurs during the signing process
                console.error("Error:", e);
                showMessage("<strong>Error:</strong> " + e.msg);  // Show an error message to the user
            }
        } else {
            // If the server response is not a string, log the error
            console.log("Error: " + t);
        }
    });
}


function openModal(msg) {
    document.getElementById("wallet_address").innerText = msg;
    document.getElementById("moweb3_test_modal").style.display = "block";
}

function showMessage(msg, msgType = "error") {
    let para;
    para = document.getElementById("moweb3CustomErrorMessage");
    para.innerHTML = msg;
}

function clearMessage() {
    let para;
    para = document.getElementById("moweb3CustomErrorMessage");
    para.innerHTML = '';
    jQuery("body").append(jQuery("#multipleCryptowalletModal"));
}
